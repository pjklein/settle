// node_modules/@stacks/network/dist/esm/constants.js
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["Mainnet"] = 1] = "Mainnet";
  ChainId2[ChainId2["Testnet"] = 2147483648] = "Testnet";
})(ChainId || (ChainId = {}));
var PeerNetworkId;
(function(PeerNetworkId2) {
  PeerNetworkId2[PeerNetworkId2["Mainnet"] = 385875968] = "Mainnet";
  PeerNetworkId2[PeerNetworkId2["Testnet"] = 4278190080] = "Testnet";
})(PeerNetworkId || (PeerNetworkId = {}));
var DEFAULT_CHAIN_ID = ChainId.Mainnet;
var TransactionVersion;
(function(TransactionVersion2) {
  TransactionVersion2[TransactionVersion2["Mainnet"] = 0] = "Mainnet";
  TransactionVersion2[TransactionVersion2["Testnet"] = 128] = "Testnet";
})(TransactionVersion || (TransactionVersion = {}));
var AddressVersion;
(function(AddressVersion2) {
  AddressVersion2[AddressVersion2["MainnetSingleSig"] = 22] = "MainnetSingleSig";
  AddressVersion2[AddressVersion2["MainnetMultiSig"] = 20] = "MainnetMultiSig";
  AddressVersion2[AddressVersion2["TestnetSingleSig"] = 26] = "TestnetSingleSig";
  AddressVersion2[AddressVersion2["TestnetMultiSig"] = 21] = "TestnetMultiSig";
})(AddressVersion || (AddressVersion = {}));
var DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;
function whenTransactionVersion(transactionVersion) {
  return (map) => map[transactionVersion];
}

// node_modules/@stacks/network/node_modules/@stacks/common/dist/esm/errors.js
var ERROR_CODES = {
  MISSING_PARAMETER: "missing_parameter",
  REMOTE_SERVICE_ERROR: "remote_service_error",
  INVALID_STATE: "invalid_state",
  NO_SESSION_DATA: "no_session_data",
  DOES_NOT_EXIST: "does_not_exist",
  FAILED_DECRYPTION_ERROR: "failed_decryption_error",
  INVALID_DID_ERROR: "invalid_did_error",
  NOT_ENOUGH_FUNDS_ERROR: "not_enough_error",
  INVALID_AMOUNT_ERROR: "invalid_amount_error",
  LOGIN_FAILED_ERROR: "login_failed",
  SIGNATURE_VERIFICATION_ERROR: "signature_verification_failure",
  CONFLICT_ERROR: "conflict_error",
  NOT_ENOUGH_PROOF_ERROR: "not_enough_proof_error",
  BAD_PATH_ERROR: "bad_path_error",
  VALIDATION_ERROR: "validation_error",
  PAYLOAD_TOO_LARGE_ERROR: "payload_too_large_error",
  PRECONDITION_FAILED_ERROR: "precondition_failed_error",
  UNKNOWN: "unknown"
};
Object.freeze(ERROR_CODES);

// node_modules/@stacks/network/node_modules/@stacks/common/dist/esm/logger.js
var levels = ["debug", "info", "warn", "error", "none"];
var levelToInt = {};
var intToLevel = {};
for (let index = 0; index < levels.length; index++) {
  const level = levels[index];
  levelToInt[level] = index;
  intToLevel[index] = level;
}

// node_modules/@stacks/network/node_modules/@stacks/common/dist/esm/utils.js
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));

// node_modules/@stacks/network/node_modules/@stacks/common/dist/esm/constants.js
var HIRO_MAINNET_URL = "https://api.mainnet.hiro.so";
var HIRO_TESTNET_URL = "https://api.testnet.hiro.so";
var DEVNET_URL = "http://localhost:3999";

// node_modules/@stacks/network/node_modules/@stacks/common/dist/esm/fetch.js
var defaultFetchOpts = {
  referrerPolicy: "origin",
  headers: {
    "x-hiro-product": "stacksjs"
  }
};
async function fetchWrapper(input, init) {
  const fetchOpts = {};
  Object.assign(fetchOpts, defaultFetchOpts, init);
  const fetchResult = await fetch(input, fetchOpts);
  return fetchResult;
}
function hostMatches(host, pattern) {
  if (typeof pattern === "string")
    return pattern === host;
  return pattern.exec(host);
}
function createApiKeyMiddleware({ apiKey, host = /(.*)api(.*)(\.stacks\.co|\.hiro\.so)$/i, httpHeader = "x-api-key" }) {
  return {
    pre: (context) => {
      const reqUrl = new URL(context.url);
      if (!hostMatches(reqUrl.host, host))
        return;
      const headers = context.init.headers instanceof Headers ? context.init.headers : context.init.headers = new Headers(context.init.headers);
      headers.set(httpHeader, apiKey);
    }
  };
}
function argsForCreateFetchFn(args) {
  let fetchLib = fetchWrapper;
  let middlewares = [];
  if (args.length > 0 && typeof args[0] === "function") {
    fetchLib = args.shift();
  }
  if (args.length > 0) {
    middlewares = args;
  }
  return { fetchLib, middlewares };
}
function createFetchFn(...args) {
  const { fetchLib, middlewares } = argsForCreateFetchFn(args);
  const fetchFn = async (url, init) => {
    let fetchParams = { url, init: init ?? {} };
    for (const middleware of middlewares) {
      if (typeof middleware.pre === "function") {
        const result = await Promise.resolve(middleware.pre({
          fetch: fetchLib,
          ...fetchParams
        }));
        fetchParams = result ?? fetchParams;
      }
    }
    let response = await fetchLib(fetchParams.url, fetchParams.init);
    for (const middleware of middlewares) {
      if (typeof middleware.post === "function") {
        const result = await Promise.resolve(middleware.post({
          fetch: fetchLib,
          url: fetchParams.url,
          init: fetchParams.init,
          response: (response == null ? void 0 : response.clone()) ?? response
        }));
        response = result ?? response;
      }
    }
    return response;
  };
  return fetchFn;
}

// node_modules/@stacks/network/dist/esm/network.js
var STACKS_MAINNET = {
  chainId: ChainId.Mainnet,
  transactionVersion: TransactionVersion.Mainnet,
  peerNetworkId: PeerNetworkId.Mainnet,
  magicBytes: "X2",
  bootAddress: "SP000000000000000000002Q6VF78",
  addressVersion: {
    singleSig: AddressVersion.MainnetSingleSig,
    multiSig: AddressVersion.MainnetMultiSig
  },
  client: { baseUrl: HIRO_MAINNET_URL }
};
var STACKS_TESTNET = {
  chainId: ChainId.Testnet,
  transactionVersion: TransactionVersion.Testnet,
  peerNetworkId: PeerNetworkId.Testnet,
  magicBytes: "T2",
  bootAddress: "ST000000000000000000002AMW42H",
  addressVersion: {
    singleSig: AddressVersion.TestnetSingleSig,
    multiSig: AddressVersion.TestnetMultiSig
  },
  client: { baseUrl: HIRO_TESTNET_URL }
};
var STACKS_DEVNET = {
  ...STACKS_TESTNET,
  addressVersion: { ...STACKS_TESTNET.addressVersion },
  magicBytes: "id",
  client: { baseUrl: DEVNET_URL }
};
var STACKS_MOCKNET = {
  ...STACKS_DEVNET,
  addressVersion: { ...STACKS_DEVNET.addressVersion },
  client: { ...STACKS_DEVNET.client }
};
var StacksNetworks = ["mainnet", "testnet", "devnet", "mocknet"];
function networkFromName(name) {
  switch (name) {
    case "mainnet":
      return STACKS_MAINNET;
    case "testnet":
      return STACKS_TESTNET;
    case "devnet":
      return STACKS_DEVNET;
    case "mocknet":
      return STACKS_MOCKNET;
    default:
      throw new Error(`Unknown network name: ${name}`);
  }
}
function networkFrom(network) {
  if (typeof network === "string")
    return networkFromName(network);
  return network;
}
function defaultUrlFromNetwork(network) {
  if (!network)
    return HIRO_MAINNET_URL;
  network = networkFrom(network);
  return !network || network.transactionVersion === TransactionVersion.Mainnet ? HIRO_MAINNET_URL : network.magicBytes === "id" ? DEVNET_URL : HIRO_TESTNET_URL;
}
function clientFromNetwork(network) {
  if (network.client.fetch)
    return network.client;
  return {
    ...network.client,
    fetch: createFetchFn()
  };
}
function createNetwork(arg1, arg2) {
  const baseNetwork = networkFrom(typeof arg1 === "object" && "network" in arg1 ? arg1.network : arg1);
  const newNetwork = {
    ...baseNetwork,
    addressVersion: { ...baseNetwork.addressVersion },
    client: { ...baseNetwork.client }
  };
  if (typeof arg1 === "object" && "network" in arg1) {
    if (arg1.client) {
      newNetwork.client.baseUrl = arg1.client.baseUrl ?? newNetwork.client.baseUrl;
      newNetwork.client.fetch = arg1.client.fetch ?? newNetwork.client.fetch;
    }
    if (typeof arg1.apiKey === "string") {
      const middleware = createApiKeyMiddleware(arg1);
      newNetwork.client.fetch = newNetwork.client.fetch ? createFetchFn(newNetwork.client.fetch, middleware) : createFetchFn(middleware);
    }
    return newNetwork;
  }
  if (typeof arg2 === "string") {
    const middleware = createApiKeyMiddleware({ apiKey: arg2 });
    newNetwork.client.fetch = newNetwork.client.fetch ? createFetchFn(newNetwork.client.fetch, middleware) : createFetchFn(middleware);
    return newNetwork;
  }
  return newNetwork;
}

export {
  ChainId,
  PeerNetworkId,
  DEFAULT_CHAIN_ID,
  TransactionVersion,
  AddressVersion,
  DEFAULT_TRANSACTION_VERSION,
  whenTransactionVersion,
  STACKS_MAINNET,
  STACKS_TESTNET,
  STACKS_DEVNET,
  STACKS_MOCKNET,
  StacksNetworks,
  networkFromName,
  networkFrom,
  defaultUrlFromNetwork,
  clientFromNetwork,
  createNetwork
};
//# sourceMappingURL=chunk-3ASSPCD5.js.map
