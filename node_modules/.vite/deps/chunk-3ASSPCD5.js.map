{
  "version": 3,
  "sources": ["../../@stacks/network/src/constants.ts", "../../@stacks/network/node_modules/@stacks/common/src/errors.ts", "../../@stacks/network/node_modules/@stacks/common/src/logger.ts", "../../@stacks/network/node_modules/@stacks/common/src/utils.ts", "../../@stacks/network/node_modules/@stacks/common/src/constants.ts", "../../@stacks/network/node_modules/@stacks/common/src/fetch.ts", "../../@stacks/network/src/network.ts"],
  "sourcesContent": ["/**\n * The chain ID (unsigned 32-bit integer), used so transactions can't be replayed on other chains.\n * Similar to the {@link TransactionVersion}.\n */\nexport enum ChainId {\n  Mainnet = 0x00000001,\n  Testnet = 0x80000000,\n}\n\n/**\n * The **peer** network ID.\n * Typically not used in signing, but used for broadcasting to the P2P network.\n * It can also be used to determine the parent of a subnet.\n *\n * **Attention:**\n * For mainnet/testnet the v2/info response `.network_id` refers to the chain ID.\n * For subnets the v2/info response `.network_id` refers to the peer network ID and the chain ID (they are the same for subnets).\n * The `.parent_network_id` refers to the actual peer network ID (of the parent) in both cases.\n */\nexport enum PeerNetworkId {\n  Mainnet = 0x17000000,\n  Testnet = 0xff000000,\n}\n\nexport const DEFAULT_CHAIN_ID = ChainId.Mainnet;\n\n/**\n * The transaction version, used so transactions can't be replayed on other networks.\n * Similar to the {@link ChainId}.\n * Used internally for serializing and deserializing transactions.\n */\nexport enum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\n/**\n * Address versions for identifying address types in an encoded Stacks address.\n * The address version is a single byte, indicating the address type.\n * Every Stacks address starts with `S` followed by a single character indicating the address version.\n * The second character is the c32-encoded AddressVersion byte.\n */\nexport enum AddressVersion {\n  /** `P` — A single-sig address for mainnet (starting with `SP`) */\n  MainnetSingleSig = 22,\n  /** `M` — A multi-sig address for mainnet (starting with `SM`) */\n  MainnetMultiSig = 20,\n  /** `T` — A single-sig address for testnet (starting with `ST`) */\n  TestnetSingleSig = 26,\n  /** `N` — A multi-sig address for testnet (starting with `SN`) */\n  TestnetMultiSig = 21,\n}\n\nexport const DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\n\n/** @ignore */\nexport function whenTransactionVersion(transactionVersion: TransactionVersion) {\n  return <T>(map: Record<TransactionVersion, T>): T => map[transactionVersion];\n}\n", "/**\n * @ignore\n */\nexport const ERROR_CODES = {\n  MISSING_PARAMETER: 'missing_parameter',\n  REMOTE_SERVICE_ERROR: 'remote_service_error',\n  INVALID_STATE: 'invalid_state',\n  NO_SESSION_DATA: 'no_session_data',\n  DOES_NOT_EXIST: 'does_not_exist',\n  FAILED_DECRYPTION_ERROR: 'failed_decryption_error',\n  INVALID_DID_ERROR: 'invalid_did_error',\n  NOT_ENOUGH_FUNDS_ERROR: 'not_enough_error',\n  INVALID_AMOUNT_ERROR: 'invalid_amount_error',\n  LOGIN_FAILED_ERROR: 'login_failed',\n  SIGNATURE_VERIFICATION_ERROR: 'signature_verification_failure',\n  CONFLICT_ERROR: 'conflict_error',\n  NOT_ENOUGH_PROOF_ERROR: 'not_enough_proof_error',\n  BAD_PATH_ERROR: 'bad_path_error',\n  VALIDATION_ERROR: 'validation_error',\n  PAYLOAD_TOO_LARGE_ERROR: 'payload_too_large_error',\n  PRECONDITION_FAILED_ERROR: 'precondition_failed_error',\n  UNKNOWN: 'unknown',\n};\n\nObject.freeze(ERROR_CODES);\n\n/**\n * @ignore\n */\ntype ErrorData = {\n  code: string;\n  parameter?: string;\n  message: string;\n};\n\n/**\n * @ignore\n */\nexport class BlockstackError extends Error {\n  message: string;\n\n  code: string;\n\n  parameter?: string;\n\n  constructor(error: ErrorData) {\n    super();\n    let message = error.message;\n    let bugDetails = `Error Code: ${error.code}`;\n    let stack = this.stack;\n    if (!stack) {\n      try {\n        throw new Error();\n      } catch (e: any) {\n        stack = e.stack;\n      }\n    } else {\n      bugDetails += `Stack Trace:\\n${stack}`;\n    }\n    message += `\\nIf you believe this exception is caused by a bug in stacks.js,\n      please file a bug report: https://github.com/blockstack/stacks.js/issues\\n\\n${bugDetails}`;\n    this.message = message;\n    this.code = error.code;\n    this.parameter = error.parameter ? error.parameter : undefined;\n  }\n\n  toString() {\n    return `${super.toString()}\n    code: ${this.code} param: ${this.parameter ? this.parameter : 'n/a'}`;\n  }\n}\n\n/**\n * @ignore\n */\nexport class InvalidParameterError extends BlockstackError {\n  constructor(parameter: string, message: string = '') {\n    super({ code: ERROR_CODES.MISSING_PARAMETER, message, parameter });\n    this.name = 'MissingParametersError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class MissingParameterError extends BlockstackError {\n  constructor(parameter: string, message: string = '') {\n    super({ code: ERROR_CODES.MISSING_PARAMETER, message, parameter });\n    this.name = 'MissingParametersError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class RemoteServiceError extends BlockstackError {\n  response: Response;\n\n  constructor(response: Response, message: string = '') {\n    super({ code: ERROR_CODES.REMOTE_SERVICE_ERROR, message });\n    this.response = response;\n  }\n}\n\n/**\n * @ignore\n */\nexport class InvalidDIDError extends BlockstackError {\n  constructor(message: string = '') {\n    super({ code: ERROR_CODES.INVALID_DID_ERROR, message });\n    this.name = 'InvalidDIDError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class NotEnoughFundsError extends BlockstackError {\n  leftToFund: number;\n\n  constructor(leftToFund: number) {\n    const message = `Not enough UTXOs to fund. Left to fund: ${leftToFund}`;\n    super({ code: ERROR_CODES.NOT_ENOUGH_FUNDS_ERROR, message });\n    this.leftToFund = leftToFund;\n    this.name = 'NotEnoughFundsError';\n    this.message = message;\n  }\n}\n\n/**\n * @ignore\n */\nexport class InvalidAmountError extends BlockstackError {\n  fees: number;\n\n  specifiedAmount: number;\n\n  constructor(fees: number, specifiedAmount: number) {\n    const message =\n      `Not enough coin to fund fees transaction fees. Fees would be ${fees},` +\n      ` specified spend is  ${specifiedAmount}`;\n    super({ code: ERROR_CODES.INVALID_AMOUNT_ERROR, message });\n    this.specifiedAmount = specifiedAmount;\n    this.fees = fees;\n    this.name = 'InvalidAmountError';\n    this.message = message;\n  }\n}\n\n/**\n * @ignore\n */\nexport class LoginFailedError extends BlockstackError {\n  constructor(reason: string) {\n    const message = `Failed to login: ${reason}`;\n    super({ code: ERROR_CODES.LOGIN_FAILED_ERROR, message });\n    this.message = message;\n    this.name = 'LoginFailedError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class SignatureVerificationError extends BlockstackError {\n  constructor(reason: string) {\n    const message = `Failed to verify signature: ${reason}`;\n    super({ code: ERROR_CODES.SIGNATURE_VERIFICATION_ERROR, message });\n    this.message = message;\n    this.name = 'SignatureVerificationError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class FailedDecryptionError extends BlockstackError {\n  constructor(message: string = 'Unable to decrypt cipher object.') {\n    super({ code: ERROR_CODES.FAILED_DECRYPTION_ERROR, message });\n    this.message = message;\n    this.name = 'FailedDecryptionError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class InvalidStateError extends BlockstackError {\n  constructor(message: string) {\n    super({ code: ERROR_CODES.INVALID_STATE, message });\n    this.message = message;\n    this.name = 'InvalidStateError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class NoSessionDataError extends BlockstackError {\n  constructor(message: string) {\n    super({ code: ERROR_CODES.INVALID_STATE, message });\n    this.message = message;\n    this.name = 'NoSessionDataError';\n  }\n}\n\n/**\n * @ignore\n */\nexport interface GaiaHubErrorResponse {\n  status: number;\n  statusText: string;\n  body?: any; // todo: should this be string?\n}\n\nexport interface HubErrorDetails {\n  message?: string;\n  statusCode: number;\n  statusText: string;\n  [prop: string]: any;\n}\n\n/**\n * @ignore\n */\nexport class GaiaHubError extends BlockstackError {\n  hubError?: HubErrorDetails;\n\n  constructor(error: ErrorData, response: GaiaHubErrorResponse) {\n    super(error);\n    if (response) {\n      this.hubError = {\n        statusCode: response.status,\n        statusText: response.statusText,\n      };\n      if (typeof response.body === 'string') {\n        this.hubError.message = response.body;\n      } else if (typeof response.body === 'object') {\n        Object.assign(this.hubError, response.body);\n      }\n    }\n  }\n}\n\n/**\n * @ignore\n */\nexport class DoesNotExist extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.DOES_NOT_EXIST }, response);\n    this.name = 'DoesNotExist';\n  }\n}\n\n/**\n * @ignore\n */\nexport class ConflictError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.CONFLICT_ERROR }, response);\n    this.name = 'ConflictError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class NotEnoughProofError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.NOT_ENOUGH_PROOF_ERROR }, response);\n    this.name = 'NotEnoughProofError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class BadPathError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.BAD_PATH_ERROR }, response);\n    this.name = 'BadPathError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class ValidationError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.VALIDATION_ERROR }, response);\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * @ignore\n */\nexport class PayloadTooLargeError extends GaiaHubError {\n  /** Can be `null` when an oversized payload is detected client-side. */\n  hubError?: HubErrorDetails;\n\n  maxUploadByteSize: number;\n\n  constructor(message: string, response: GaiaHubErrorResponse | null, maxUploadByteSize: number) {\n    super({ message, code: ERROR_CODES.PAYLOAD_TOO_LARGE_ERROR }, response!);\n    this.name = 'PayloadTooLargeError';\n    this.maxUploadByteSize = maxUploadByteSize;\n  }\n}\n\n/**\n * @ignore\n */\nexport class PreconditionFailedError extends GaiaHubError {\n  constructor(message: string, response: GaiaHubErrorResponse) {\n    super({ message, code: ERROR_CODES.PRECONDITION_FAILED_ERROR }, response);\n    this.name = 'PreconditionFailedError';\n  }\n}\n", "import { config } from './config';\n\nconst levels = ['debug', 'info', 'warn', 'error', 'none'];\n\nconst levelToInt: { [level: string]: number } = {};\nconst intToLevel: { [int: number]: string } = {};\n\nfor (let index = 0; index < levels.length; index++) {\n  const level = levels[index];\n  levelToInt[level] = index;\n  intToLevel[index] = level;\n}\n\n/**\n * @ignore\n * @deprecated\n */\nexport class Logger {\n  static error(message: string) {\n    if (!this.shouldLog('error')) return;\n    console.error(this.logMessage('error', message));\n  }\n\n  static warn(message: string) {\n    if (!this.shouldLog('warn')) return;\n    console.warn(this.logMessage('warn', message));\n  }\n\n  static info(message: string) {\n    if (!this.shouldLog('info')) return;\n    console.log(this.logMessage('info', message));\n  }\n\n  static debug(message: string) {\n    if (!this.shouldLog('debug')) return;\n    console.log(this.logMessage('debug', message));\n  }\n\n  static logMessage(level: string, message: string) {\n    return `[${level.toUpperCase()}] ${message}`;\n  }\n\n  static shouldLog(level: string) {\n    const currentLevel = levelToInt[config.logLevel];\n    return currentLevel <= levelToInt[level];\n  }\n}\n", "import { Logger } from './logger';\n\n/**\n *  @ignore\n * @deprecated\n */\nexport const BLOCKSTACK_HANDLER = 'blockstack';\n// todo: `next` get rid of all this blockstack stuff\n\n/**\n * Time\n * @private\n * @ignore\n * @deprecated\n */\nexport function nextYear() {\n  return new Date(new Date().setFullYear(new Date().getFullYear() + 1));\n}\n\n/**\n * Time\n * @private\n * @ignore\n * @deprecated\n */\nexport function nextMonth() {\n  return new Date(new Date().setMonth(new Date().getMonth() + 1));\n}\n\n/**\n * Time\n * @private\n * @ignore\n * @deprecated\n */\nexport function nextHour() {\n  return new Date(new Date().setHours(new Date().getHours() + 1));\n}\n\n/**\n * Converts megabytes to bytes. Returns 0 if the input is not a finite number.\n * @ignore\n * @deprecated\n */\nexport function megabytesToBytes(megabytes: number): number {\n  if (!Number.isFinite(megabytes)) {\n    return 0;\n  }\n  return Math.floor(megabytes * 1024 * 1024);\n}\n\n/**\n * Calculate the AES-CBC ciphertext output byte length a given input length.\n * AES has a fixed block size of 16-bytes regardless key size.\n * @ignore\n * @deprecated\n */\nexport function getAesCbcOutputLength(inputByteLength: number) {\n  // AES-CBC block mode rounds up to the next block size.\n  const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;\n  return cipherTextLength;\n}\n\n/**\n * Calculate the base64 encoded string length for a given input length.\n * This is equivalent to the byte length when the string is ASCII or UTF8-8\n * encoded.\n * @param number\n * @deprecated\n */\nexport function getBase64OutputLength(inputByteLength: number) {\n  const encodedLength = Math.ceil(inputByteLength / 3) * 4;\n  return encodedLength;\n}\n\n/**\n * Query Strings\n * @private\n * @ignore\n * @deprecated\n */\nexport function updateQueryStringParameter(uri: string, key: string, value: string) {\n  const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');\n  const separator = uri.indexOf('?') !== -1 ? '&' : '?';\n  if (uri.match(re)) {\n    return uri.replace(re, `$1${key}=${value}$2`);\n  } else {\n    return `${uri}${separator}${key}=${value}`;\n  }\n}\n\n/**\n * Versioning\n * @param {string} v1 - the left half of the version inequality\n * @param {string} v2 - right half of the version inequality\n * @returns {bool} iff v1 >= v2\n * @private\n * @ignore\n * @deprecated\n */\nexport function isLaterVersion(v1: string, v2: string) {\n  if (v1 === undefined || v1 === '') {\n    v1 = '0.0.0';\n  }\n\n  if (v2 === undefined || v1 === '') {\n    v2 = '0.0.0';\n  }\n\n  const v1tuple = v1.split('.').map(x => parseInt(x, 10));\n  const v2tuple = v2.split('.').map(x => parseInt(x, 10));\n\n  for (let index = 0; index < v2.length; index++) {\n    if (index >= v1.length) {\n      v2tuple.push(0);\n    }\n    if (v1tuple[index] < v2tuple[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * UUIDs\n * @private\n * @ignore\n * @deprecated\n */\nexport function makeUUID4() {\n  let d = new Date().getTime();\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    d += performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n\n/**\n * Checks if both urls pass the same origin check & are absolute\n * @param  {[type]}  uri1 first uri to check\n * @param  {[type]}  uri2 second uri to check\n * @return {Boolean} true if they pass the same origin check\n * @private\n * @ignore\n * @deprecated\n */\nexport function isSameOriginAbsoluteUrl(uri1: string, uri2: string) {\n  try {\n    const parsedUri1 = new URL(uri1);\n    const parsedUri2 = new URL(uri2);\n\n    const port1 =\n      parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);\n    const port2 =\n      parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);\n\n    const match = {\n      scheme: parsedUri1.protocol === parsedUri2.protocol,\n      hostname: parsedUri1.hostname === parsedUri2.hostname,\n      port: port1 === port2,\n      absolute:\n        (uri1.includes('http://') || uri1.includes('https://')) &&\n        (uri2.includes('http://') || uri2.includes('https://')),\n    };\n\n    return match.scheme && match.hostname && match.port && match.absolute;\n  } catch (error) {\n    console.log(error);\n    console.log('Parsing error in same URL origin check');\n    // Parse error\n    return false;\n  }\n}\n\n/**\n * Returns the global scope `Window`, `WorkerGlobalScope`, or `NodeJS.Global` if available in the\n * currently executing environment.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/self\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope\n *\n * This could be switched to `globalThis` once it is standardized and widely available.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\n * @ignore\n */\nexport function getGlobalScope(): Window {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  // This function is meant to be called when accessing APIs that are typically only available in\n  // web-browser/DOM environments, but we also want to support situations where running in Node.js\n  // environment, and a polyfill was added to the Node.js `global` object scope without adding the\n  // `window` global object as well.\n  if (typeof global !== 'undefined') {\n    return global as unknown as Window;\n  }\n  throw new Error(\n    'Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available'\n  );\n}\n\n/** @deprecated */\nfunction getAPIUsageErrorMessage(\n  scopeObject: unknown,\n  apiName: string,\n  usageDesc?: string\n): string {\n  if (usageDesc) {\n    return `Use of '${usageDesc}' requires \\`${apiName}\\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n  } else {\n    return `\\`${apiName}\\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n  }\n}\n\ninterface GetGlobalObjectOptions {\n  /**\n   * Throw an error if the object is not found.\n   * @default false\n   */\n  throwIfUnavailable?: boolean;\n  /**\n   * Additional information to include in an error if thrown.\n   */\n  usageDesc?: string;\n  /**\n   * If the object is not found, return an new empty object instead of undefined.\n   * Requires [[throwIfUnavailable]] to be falsey.\n   * @default false\n   */\n  returnEmptyObject?: boolean;\n}\n\n/**\n * Returns an object from the global scope (`Window` or `WorkerGlobalScope`) if it\n * is available within the currently executing environment.\n * When executing within the Node.js runtime these APIs are unavailable and will be\n * `undefined` unless the API is provided via polyfill.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @ignore\n */\nexport function getGlobalObject<K extends Extract<keyof Window, string>>(\n  name: K,\n  { throwIfUnavailable, usageDesc, returnEmptyObject }: GetGlobalObjectOptions = {}\n): Window[K] | undefined {\n  let globalScope: Window | undefined = undefined;\n  try {\n    globalScope = getGlobalScope();\n    if (globalScope) {\n      const obj = globalScope[name];\n      if (obj) {\n        return obj;\n      }\n    }\n  } catch (error) {\n    Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);\n  }\n  if (throwIfUnavailable) {\n    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n    Logger.error(errMsg);\n    throw new Error(errMsg);\n  }\n  if (returnEmptyObject) {\n    return {} as any;\n  }\n  return undefined;\n}\n\n/**\n * Returns a specified subset of objects from the global scope (`Window` or `WorkerGlobalScope`)\n * if they are available within the currently executing environment.\n * When executing within the Node.js runtime these APIs are unavailable will be `undefined`\n * unless the API is provided via polyfill.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @ignore\n */\nexport function getGlobalObjects<K extends Extract<keyof Window, string>>(\n  names: K[],\n  { throwIfUnavailable, usageDesc, returnEmptyObject }: GetGlobalObjectOptions = {}\n): Pick<Window, K> {\n  let globalScope: Window | undefined;\n  try {\n    globalScope = getGlobalScope();\n  } catch (error) {\n    Logger.error(`Error getting global scope: ${error}`);\n    if (throwIfUnavailable) {\n      const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);\n      Logger.error(errMsg);\n      throw errMsg;\n    } else if (returnEmptyObject) {\n      globalScope = {} as any;\n    }\n  }\n\n  const result: Pick<Window, K> = {} as any;\n  for (let i = 0; i < names.length; i++) {\n    const name = names[i];\n    try {\n      if (globalScope) {\n        const obj = globalScope[name];\n        if (obj) {\n          result[name] = obj;\n        } else if (throwIfUnavailable) {\n          const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n          Logger.error(errMsg);\n          throw new Error(errMsg);\n        } else if (returnEmptyObject) {\n          result[name] = {} as any;\n        }\n      }\n    } catch (error) {\n      if (throwIfUnavailable) {\n        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n        Logger.error(errMsg);\n        throw new Error(errMsg);\n      }\n    }\n  }\n  return result;\n}\n\n/** Different Integer representations */\nexport type IntegerType = number | string | bigint | Uint8Array;\n\n/**\n * Converts an integer-compatible value to a Uint8Array (given a byte length)\n * @example\n * ```ts\n * import { intToBytes } from \"@stacks/common\";\n * console.log(intToBytes(560, 4));\n * // Uint8Array(4) [ 0, 0, 2, 48 ]\n * ```\n */\nexport function intToBytes(value: IntegerType, byteLength: number): Uint8Array {\n  return bigIntToBytes(intToBigInt(value), byteLength);\n}\n\n/**\n * Converts an integer-compatible value to a bigint\n * @param value - The value to convert to a bigint\n * @returns The bigint representation of the value\n *\n * @example\n * ```ts\n * intToBigInt(123); // 123n\n * intToBigInt('0xbeef'); // 48879n\n * ```\n */\nexport function intToBigInt(value: IntegerType): bigint {\n  if (typeof value === 'bigint') return value;\n  if (typeof value === 'string') return BigInt(value);\n  if (typeof value === 'number') {\n    if (!Number.isInteger(value)) {\n      throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);\n    }\n    if (value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError(\n        `Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`\n      );\n    }\n    return BigInt(value);\n  }\n\n  if (isInstance(value, Uint8Array)) return BigInt(`0x${bytesToHex(value)}`);\n\n  throw new TypeError(\n    `intToBigInt: Invalid value type. Must be a number, bigint, BigInt-compatible string, or Uint8Array.`\n  );\n}\n\n/**\n * Adds a `0x` prefix to a string if it does not already have one.\n */\nexport function with0x(value: string): string {\n  return /^0x/i.test(value) // startsWith('0x') case insensitive\n    ? value\n    : `0x${value}`;\n}\n\n/**\n * Removes the `0x` prefix of a string if it has one.\n */\nexport function without0x(value: string): string {\n  return /^0x/i.test(value) // startsWith('0x') case insensitive\n    ? value.slice(2)\n    : value;\n}\n\n/**\n * Converts hex input string to bigint\n * @param hex - hex input string without 0x prefix and in big endian format\n * @example \"6c7cde4d702830c1db34ef7c19e2776f59107afef39084776fc88bc78dbb9656\"\n * @ignore\n */\nexport function hexToBigInt(hex: string): bigint {\n  if (typeof hex !== 'string')\n    throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);\n  // Big Endian\n  return BigInt(`0x${hex}`);\n}\n\n/**\n * Converts IntegerType to hex string\n */\nexport function intToHex(integer: IntegerType, byteLength = 8): string {\n  const value = typeof integer === 'bigint' ? integer : intToBigInt(integer);\n  return value.toString(16).padStart(byteLength * 2, '0');\n}\n\n/**\n * Converts hex string to integer\n */\nexport function hexToInt(hex: string): number {\n  return parseInt(hex, 16);\n}\n\n/**\n * Converts bigint to byte array\n * @param value bigint value to be converted\n * @param length byte array optional length\n * @return {Uint8Array} byte array\n */\nexport function bigIntToBytes(value: bigint, length: number = 16): Uint8Array {\n  const hex = intToHex(value, length);\n  return hexToBytes(hex);\n}\n\n/**\n * Converts from signed number to two's complement\n * MIN_VALUE = -(1 << (width - 1))\n * MAX_VALUE =  (1 << (width - 1)) - 1\n * @ignore\n */\nexport function toTwos(value: bigint, width: bigint): bigint {\n  if (\n    value < -(BigInt(1) << (width - BigInt(1))) ||\n    (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value\n  ) {\n    throw `Unable to represent integer in width: ${width}`;\n  }\n  if (value >= BigInt(0)) {\n    return BigInt(value);\n  }\n  return value + (BigInt(1) << width);\n}\n\n/**\n * Returns nth bit (right-to-left, zero-indexed)\n */\nfunction nthBit(value: bigint, n: bigint) {\n  return value & (BigInt(1) << n);\n}\n\n/** @ignore */\nexport function bytesToTwosBigInt(bytes: Uint8Array): bigint {\n  return fromTwos(BigInt(`0x${bytesToHex(bytes)}`), BigInt(bytes.byteLength * 8));\n}\n\n/**\n * Converts from two's complement to signed number\n * @internal\n */\nexport function fromTwos(value: bigint, width: bigint) {\n  if (nthBit(value, width - BigInt(1))) {\n    return value - (BigInt(1) << width);\n  }\n  return value;\n}\n\n// The following methods are based on `@noble/hashes` implementation\n// https://github.com/paulmillr/noble-hashes\n// Copyright (c) 2022 Paul Miller (https://paulmillr.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the “Software”), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\nconst hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n\n/**\n * Converts bytes to the equivalent hex string\n * @example\n * ```\n * bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'\n * ```\n */\nexport function bytesToHex(uint8a: Uint8Array): string {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (const u of uint8a) {\n    hex += hexes[u];\n  }\n  return hex;\n}\n\n/**\n * Converts a hex string to the equivalent bytes\n * @example\n * ```\n * hexToBytes('deadbeef') // Uint8Array(4) [ 222, 173, 190, 239 ]\n * hexToBytes('0xdeadbeef') // Uint8Array(4) [ 222, 173, 190, 239 ]\n * ```\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') {\n    throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);\n  }\n\n  hex = without0x(hex);\n  hex = hex.length % 2 ? `0${hex}` : hex; // left pad with a zero if odd length\n\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts a UTF-8 string to the equivalent bytes\n * @example\n * ```\n * utf8ToBytes('stacks Ӿ'); // Uint8Array(9) [ 115, 116, 97, 99, 107, 115, 32, 211, 190 ];\n * ```\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  return new TextEncoder().encode(str);\n}\n\n/**\n * Converts bytes to the equivalent UTF-8 string\n * @example\n * ```\n * bytesToUtf8(Uint8Array.from([115, 116, 97, 99, 107, 115, 32, 211, 190])); // 'stacks Ӿ'\n * ```\n */\nexport function bytesToUtf8(arr: Uint8Array): string {\n  return new TextDecoder().decode(arr);\n}\n\n/**\n * Converts an ASCII string to the equivalent bytes\n * @example\n * ```\n * asciiToBytes('stacks $'); // Uint8Array(8) [ 115, 116, 97, 99, 107, 115, 32, 36 ]\n * ```\n */\nexport function asciiToBytes(str: string) {\n  const byteArray = [];\n  for (let i = 0; i < str.length; i++) {\n    byteArray.push(str.charCodeAt(i) & 0xff); // ignore second bytes of UTF-16 character\n  }\n  return new Uint8Array(byteArray);\n}\n\n/**\n * Converts bytes to the equivalent ASCII string\n * @example\n * ```\n * bytesToAscii(Uint8Array.from([115, 116, 97, 99, 107, 115, 32, 36])); // 'stacks $'\n * ```\n */\nexport function bytesToAscii(arr: Uint8Array) {\n  return String.fromCharCode.apply(null, arr as any as number[]);\n}\n\nfunction isNotOctet(octet: number) {\n  return !Number.isInteger(octet) || octet < 0 || octet > 255;\n}\n\n/** @ignore */\nexport function octetsToBytes(numbers: number[]) {\n  if (numbers.some(isNotOctet)) throw new Error('Some values are invalid bytes.');\n  return new Uint8Array(numbers);\n}\n\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n * @ignore\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\n\n/** @ignore */\nexport function concatArray(elements: (Uint8Array | number[] | number)[]) {\n  return concatBytes(\n    ...elements.map(e => {\n      if (typeof e === 'number') return octetsToBytes([e]);\n      if (e instanceof Array) return octetsToBytes(e);\n      return e;\n    })\n  );\n}\n\n/**\n * Better `instanceof` check for types in different environments\n * @ignore\n */\nexport function isInstance<T>(object: any, clazz: { new (...args: any[]): T }): object is T {\n  return object instanceof clazz || object?.constructor?.name?.toLowerCase() === clazz.name;\n}\n\n/**\n * Checks whether a string is a valid hex string, and has a length of 64 characters.\n */\nexport function validateHash256(hex: string): boolean {\n  hex = without0x(hex);\n  if (hex.length !== 64) return false;\n  return /^[0-9a-fA-F]+$/.test(hex);\n}\n", "export const HIRO_MAINNET_URL = 'https://api.mainnet.hiro.so';\nexport const HIRO_TESTNET_URL = 'https://api.testnet.hiro.so';\nexport const DEVNET_URL = 'http://localhost:3999';\n\nexport const GAIA_URL = 'https://hub.blockstack.org';\n\n// todo: deduplicate magic variables\n\n/** @ignore internal */\nexport const PRIVATE_KEY_BYTES_COMPRESSED = 33;\n\n/** @ignore internal */\nexport const PRIVATE_KEY_BYTES_UNCOMPRESSED = 32;\n", "// Define default request options and allow modification using getters, setters\n// Reference: https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\nconst defaultFetchOpts: RequestInit = {\n  // By default referrer value will be client:origin: above reference link\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n  referrerPolicy: 'origin', // Use origin value for referrer policy\n  headers: {\n    'x-hiro-product': 'stacksjs',\n  },\n};\n\n/**\n * Get fetch options\n * @category Network\n */\nexport const getFetchOptions = () => {\n  return defaultFetchOpts;\n};\n\n/**\n * Sets global fetch options for stacks.js network calls.\n *\n * @example\n * Users can change the default referrer as well as other options when fetch is used internally by stacks.js:\n * ```\n * setFetchOptions({ referrer: 'no-referrer', referrerPolicy: 'no-referrer', ...otherRequestOptions });\n * ```\n * After calling {@link setFetchOptions} all subsequent network calls will use the specified options above.\n *\n * @see MDN Request: https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\n * @returns global fetch options after merging with previous options (or defaults)\n * @category Network\n * @related {@link getFetchOptions}\n */\nexport const setFetchOptions = (ops: RequestInit): RequestInit => {\n  return Object.assign(defaultFetchOpts, ops);\n};\n\n/** @ignore */\nexport async function fetchWrapper(input: RequestInfo, init?: RequestInit): Promise<Response> {\n  const fetchOpts = {};\n  // Use the provided options in request options along with default or user provided values\n  Object.assign(fetchOpts, defaultFetchOpts, init);\n\n  const fetchResult = await fetch(input, fetchOpts);\n  return fetchResult;\n}\n\nexport type FetchFn = (url: string, init?: RequestInit) => Promise<Response>;\n\n/**\n * @ignore Internally used for letting networking functions specify \"API\" options.\n * Should be compatible with the `client`s created by the API and RPC packages.\n */\nexport interface ClientOpts {\n  baseUrl?: string;\n  fetch?: FetchFn;\n}\n\n/** @ignore Internally used for letting networking functions specify \"API\" options */\nexport interface ClientParam {\n  /** Optional API object (for `.baseUrl` and `.fetch`) used for API/Node, defaults to use mainnet */\n  client?: ClientOpts;\n}\n\nexport interface RequestContext {\n  fetch: FetchFn;\n  url: string;\n  init: RequestInit;\n}\n\nexport interface ResponseContext {\n  fetch: FetchFn;\n  url: string;\n  init: RequestInit;\n  response: Response;\n}\n\nexport interface FetchParams {\n  url: string;\n  init: RequestInit;\n}\n\nexport interface FetchMiddleware {\n  pre?: (context: RequestContext) => PromiseLike<FetchParams | void> | FetchParams | void;\n  post?: (context: ResponseContext) => Promise<Response | void> | Response | void;\n}\nexport interface ApiKeyMiddlewareOpts {\n  /** The middleware / API key header will only be added to requests matching this host. */\n  host?: RegExp | string;\n  /** The http header name used for specifying the API key value. */\n  httpHeader?: string;\n  /** The API key string to specify as an http header value. */\n  apiKey: string;\n}\n\n/** @ignore */\nexport function hostMatches(host: string, pattern: string | RegExp) {\n  if (typeof pattern === 'string') return pattern === host;\n  return pattern.exec(host);\n}\n\n/**\n * Creates a new middleware from an API key.\n * @example\n * ```\n * const apiMiddleware = createApiKeyMiddleware(\"example_e8e044a3_41d8b0fe_3dd3988ef302\");\n * const fetchFn = createFetchFn(apiMiddleware);\n * const network = new StacksMainnet({ fetchFn });\n * ```\n * @category Network\n * @related {@link createFetchFn}, {@link StacksNetwork}\n */\nexport function createApiKeyMiddleware({\n  apiKey,\n  host = /(.*)api(.*)(\\.stacks\\.co|\\.hiro\\.so)$/i,\n  httpHeader = 'x-api-key',\n}: ApiKeyMiddlewareOpts): FetchMiddleware {\n  return {\n    pre: context => {\n      const reqUrl = new URL(context.url);\n      if (!hostMatches(reqUrl.host, host)) return; // Skip middleware if host does not match pattern\n\n      const headers =\n        context.init.headers instanceof Headers\n          ? context.init.headers\n          : (context.init.headers = new Headers(context.init.headers));\n      headers.set(httpHeader, apiKey);\n    },\n  };\n}\n\nfunction argsForCreateFetchFn(args: any[]): { fetchLib: FetchFn; middlewares: FetchMiddleware[] } {\n  let fetchLib: FetchFn = fetchWrapper;\n  let middlewares: FetchMiddleware[] = [];\n  if (args.length > 0 && typeof args[0] === 'function') {\n    fetchLib = args.shift();\n  }\n  if (args.length > 0) {\n    middlewares = args; // remaining args\n  }\n  return { fetchLib, middlewares };\n}\n\n/**\n * Creates a new network fetching function, which combines an optional fetch-compatible library with optional middleware.\n * @example\n * ```\n * const customFetch = createFetchFn(someMiddleware)\n * const customFetch = createFetchFn(fetch, someMiddleware)\n * const customFetch = createFetchFn(fetch, middlewareA, middlewareB)\n * ```\n * @category Network\n */\nexport function createFetchFn(fetchLib: FetchFn, ...middleware: FetchMiddleware[]): FetchFn;\nexport function createFetchFn(...middleware: FetchMiddleware[]): FetchFn;\nexport function createFetchFn(...args: any[]): FetchFn {\n  const { fetchLib, middlewares } = argsForCreateFetchFn(args);\n\n  const fetchFn = async (url: string, init?: RequestInit | undefined): Promise<Response> => {\n    let fetchParams = { url, init: init ?? {} };\n\n    for (const middleware of middlewares) {\n      if (typeof middleware.pre === 'function') {\n        const result = await Promise.resolve(\n          middleware.pre({\n            fetch: fetchLib,\n            ...fetchParams,\n          })\n        );\n        fetchParams = result ?? fetchParams;\n      }\n    }\n\n    let response = await fetchLib(fetchParams.url, fetchParams.init);\n\n    for (const middleware of middlewares) {\n      if (typeof middleware.post === 'function') {\n        const result = await Promise.resolve(\n          middleware.post({\n            fetch: fetchLib,\n            url: fetchParams.url,\n            init: fetchParams.init,\n            response: response?.clone() ?? response,\n          })\n        );\n        response = result ?? response;\n      }\n    }\n    return response;\n  };\n  return fetchFn;\n}\n\n// /** @ignore Creates a client-like object, which can be used without circular dependencies */\n// export function defaultClientOpts(opts?: { baseUrl?: string; fetch?: FetchFn }) {\n//   return {\n//     baseUrl: opts?.baseUrl ?? HIRO_MAINNET_URL,\n//     fetch: opts?.fetch ?? createFetchFn(),\n//   };\n// }\n", "import {\n  DEVNET_URL,\n  FetchFn,\n  HIRO_MAINNET_URL,\n  HIRO_TESTNET_URL,\n  createFetchFn,\n  createApiKeyMiddleware,\n  ClientOpts,\n  ApiKeyMiddlewareOpts,\n} from '@stacks/common';\nimport { AddressVersion, ChainId, PeerNetworkId, TransactionVersion } from './constants';\nimport { ClientParam } from '@stacks/common';\n\nexport type StacksNetwork = {\n  chainId: number;\n  transactionVersion: number;\n  peerNetworkId: number;\n  magicBytes: string;\n  bootAddress: string;\n  addressVersion: {\n    singleSig: number;\n    multiSig: number;\n  };\n  // todo: add check32 character bytes string\n  client: {\n    baseUrl: string; // URL is always required\n    fetch?: FetchFn; // fetch is optional and will be created by default in fetch helpers\n  };\n};\n\nexport interface NetworkParam {\n  network?: StacksNetworkName | StacksNetwork;\n}\n\nexport type NetworkClientParam = NetworkParam & ClientParam;\n\nexport const STACKS_MAINNET: StacksNetwork = {\n  chainId: ChainId.Mainnet,\n  transactionVersion: TransactionVersion.Mainnet,\n  peerNetworkId: PeerNetworkId.Mainnet,\n  magicBytes: 'X2', // todo: comment bytes version of magic bytes\n  bootAddress: 'SP000000000000000000002Q6VF78',\n  addressVersion: {\n    singleSig: AddressVersion.MainnetSingleSig,\n    multiSig: AddressVersion.MainnetMultiSig,\n  },\n  client: { baseUrl: HIRO_MAINNET_URL },\n};\n\nexport const STACKS_TESTNET: StacksNetwork = {\n  chainId: ChainId.Testnet,\n  transactionVersion: TransactionVersion.Testnet,\n  peerNetworkId: PeerNetworkId.Testnet,\n  magicBytes: 'T2', // todo: comment bytes version of magic bytes\n  bootAddress: 'ST000000000000000000002AMW42H',\n  addressVersion: {\n    singleSig: AddressVersion.TestnetSingleSig,\n    multiSig: AddressVersion.TestnetMultiSig,\n  },\n  client: { baseUrl: HIRO_TESTNET_URL },\n};\n\nexport const STACKS_DEVNET: StacksNetwork = {\n  ...STACKS_TESTNET, // todo: ensure deep copy\n  addressVersion: { ...STACKS_TESTNET.addressVersion }, // deep copy\n  magicBytes: 'id', // todo: comment bytes version of magic bytes\n  client: { baseUrl: DEVNET_URL },\n};\n\nexport const STACKS_MOCKNET: StacksNetwork = {\n  ...STACKS_DEVNET,\n  addressVersion: { ...STACKS_DEVNET.addressVersion }, // deep copy\n  client: { ...STACKS_DEVNET.client }, // deep copy\n};\n\n/** @ignore internal */\nexport const StacksNetworks = ['mainnet', 'testnet', 'devnet', 'mocknet'] as const;\n/** The enum-style names of different common Stacks networks */\nexport type StacksNetworkName = (typeof StacksNetworks)[number];\n\n/**\n * Returns the default network for a given name\n * @example\n * ```ts\n * networkFromName('mainnet') // same as STACKS_MAINNET\n * networkFromName('testnet') // same as STACKS_TESTNET\n * networkFromName('devnet') // same as STACKS_DEVNET\n * networkFromName('mocknet') // same as STACKS_MOCKNET\n * ```\n */\nexport function networkFromName(name: StacksNetworkName) {\n  switch (name) {\n    case 'mainnet':\n      return STACKS_MAINNET;\n    case 'testnet':\n      return STACKS_TESTNET;\n    case 'devnet':\n      return STACKS_DEVNET;\n    case 'mocknet':\n      return STACKS_MOCKNET;\n    default:\n      throw new Error(`Unknown network name: ${name}`);\n  }\n}\n\n/** @ignore */\nexport function networkFrom(network: StacksNetworkName | StacksNetwork) {\n  if (typeof network === 'string') return networkFromName(network);\n  return network;\n}\n\n/** @ignore */\nexport function defaultUrlFromNetwork(network?: StacksNetworkName | StacksNetwork) {\n  if (!network) return HIRO_MAINNET_URL; // default to mainnet if no network is given\n\n  network = networkFrom(network);\n\n  return !network || network.transactionVersion === TransactionVersion.Mainnet\n    ? HIRO_MAINNET_URL // default to mainnet if txVersion is mainnet\n    : network.magicBytes === 'id'\n      ? DEVNET_URL // default to devnet if magicBytes are devnet\n      : HIRO_TESTNET_URL;\n}\n\n/**\n * Returns the client of a network, creating a new fetch function if none is available\n */\nexport function clientFromNetwork(network: StacksNetwork): Required<ClientOpts> {\n  if (network.client.fetch) return network.client as Required<ClientOpts>;\n  return {\n    ...network.client,\n    fetch: createFetchFn(),\n  };\n}\n\n/**\n * Creates a customized Stacks network.\n *\n * This function allows you to create a network based on a predefined network\n * (mainnet, testnet, devnet, mocknet) or a custom network object. You can also customize\n * the network with an API key or other client options.\n *\n * @example\n * ```ts\n * // Create a basic network from a network name\n * const network = createNetwork('mainnet');\n * const network = createNetwork(STACKS_MAINNET);\n * ```\n *\n * @example\n * ```ts\n * // Create a network with an API key\n * const network = createNetwork('testnet', 'my-api-key');\n * const network = createNetwork(STACKS_TESTNET, 'my-api-key');\n * ```\n *\n * @example\n * ```ts\n * // Create a network with options object\n * const network = createNetwork({\n *   network: 'mainnet',\n *   apiKey: 'my-api-key',\n * });\n * ```\n *\n * @example\n * ```ts\n * // Create a network with options object with custom API key options\n * const network = createNetwork({\n *   network: 'mainnet',\n *   apiKey: 'my-api-key',\n *   host: /\\.example\\.com$/, // default is /(.*)api(.*)(\\.stacks\\.co|\\.hiro\\.so)$/i\n *   httpHeader: 'x-custom-api-key', // default is 'x-api-key'\n * });\n * ```\n *\n * @example\n * ```ts\n * // Create a network with custom client options\n * const network = createNetwork({\n *   network: STACKS_TESTNET,\n *   client: {\n *     baseUrl: 'https://custom-api.example.com',\n *     fetch: customFetchFunction\n *   }\n * });\n * ```\n */\nexport function createNetwork(network: StacksNetworkName | StacksNetwork): StacksNetwork;\nexport function createNetwork(\n  network: StacksNetworkName | StacksNetwork,\n  apiKey: string\n): StacksNetwork;\nexport function createNetwork(\n  options: {\n    network: StacksNetworkName | StacksNetwork;\n    client?: ClientOpts;\n  } & Partial<ApiKeyMiddlewareOpts>\n): StacksNetwork;\nexport function createNetwork(\n  arg1:\n    | StacksNetworkName\n    | StacksNetwork\n    | ({\n        network: StacksNetworkName | StacksNetwork;\n        client?: ClientOpts;\n      } & Partial<ApiKeyMiddlewareOpts>),\n  arg2?: string\n): StacksNetwork {\n  const baseNetwork = networkFrom(\n    typeof arg1 === 'object' && 'network' in arg1 ? arg1.network : arg1\n  );\n\n  const newNetwork: StacksNetwork = {\n    ...baseNetwork,\n    addressVersion: { ...baseNetwork.addressVersion }, // deep copy\n    client: { ...baseNetwork.client }, // deep copy\n  };\n\n  // Options object argument\n  if (typeof arg1 === 'object' && 'network' in arg1) {\n    if (arg1.client) {\n      newNetwork.client.baseUrl = arg1.client.baseUrl ?? newNetwork.client.baseUrl;\n      newNetwork.client.fetch = arg1.client.fetch ?? newNetwork.client.fetch;\n    }\n\n    if (typeof arg1.apiKey === 'string') {\n      const middleware = createApiKeyMiddleware(arg1 as ApiKeyMiddlewareOpts);\n      newNetwork.client.fetch = newNetwork.client.fetch\n        ? createFetchFn(newNetwork.client.fetch, middleware)\n        : createFetchFn(middleware);\n    }\n\n    return newNetwork;\n  }\n\n  // Additional API key argument\n  if (typeof arg2 === 'string') {\n    const middleware = createApiKeyMiddleware({ apiKey: arg2 });\n    newNetwork.client.fetch = newNetwork.client.fetch\n      ? createFetchFn(newNetwork.client.fetch, middleware)\n      : createFetchFn(middleware);\n    return newNetwork;\n  }\n\n  // Only network argument\n  return newNetwork;\n}\n"],
  "mappings": "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",
  "names": ["ChainId", "PeerNetworkId", "TransactionVersion", "AddressVersion"]
}
